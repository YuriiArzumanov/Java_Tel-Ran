На чем сосредоточены тесты на java?
Тесты на Java могут быть сосредоточены на различных уровнях приложения и проверять различные аспекты его функциональности
Модульные тесты (Unit tests):
Цель: Проверка корректности отдельных модулей (методов, классов) кода.
Фокус: Сосредоточены на изоляции и тестировании отдельных компонентов, минимизация внешних зависимостей.
Интеграционные тесты (Integration tests):
Цель: Проверка взаимодействия между различными модулями или компонентами системы.
Фокус: Сосредоточены на проверке взаимодействия между компонентами и правильном функционировании системы в целом.
Приемочные тесты (Acceptance tests):
Цель: Проверка, соответствует ли система требованиям и ожиданиям заказчика.
Фокус: Сосредоточены на функциональности системы, как видят ее пользователи. Могут включать в себя автоматизированные
тесты пользовательского интерфейса.
Тесты производительности (Performance tests):
Цель: Проверка производительности и эффективности системы при различных нагрузках.
Фокус: Сосредоточены на измерении времени выполнения операций, использовании ресурсов и общей производительности системы.
Тесты безопасности (Security tests):
Цель: Проверка на уязвимости и недостатки в области безопасности.
Фокус: Сосредоточены на идентификации и устранении уязвимостей, таких как атаки по переполнению буфера, инъекции
и другие угрозы безопасности.

Что такое unit test?
Unit test (модульный тест) - это вид тестирования программного обеспечения, в котором проверяется корректность работы
отдельных модулей или компонентов программы. Модуль в данном контексте обычно означает отдельную функцию, метод,
процедуру или класс в программном коде.
Цель:Проверка корректности работы отдельных модулей кода.
Область применения:Тестирование отдельных функций, методов, классов или других небольших компонентов программы.
Изоляция:Тесты создаются таким образом, чтобы изолировать модуль от других компонентов, минимизируя внешние зависимости.
Автоматизированность:Модульные тесты обычно автоматизированы, что позволяет быстро и эффективно запускать их в ходе
разработки и тестирования.
Сфера ответственности:Ответственность за успешное прохождение модульных тестов лежит на разработчиках, которые пишут код.
Интеграция в процесс сборки:Модульные тесты часто включаются в процесс автоматизированной сборки проекта.
Модульные тесты играют важную роль в обеспечении качества кода и упрощении обнаружения и устранения ошибок на
ранних этапах разработки.

Какие библиотеки используются для тестирования?
JUnit:
Описание: Один из самых популярных фреймворков для написания модульных тестов на языке Java.
Особенности: Поддержка аннотаций, параметризированных тестов, запуск тестов в определенном порядке и многое другое.
TestNG:
Описание: Расширенный фреймворк для тестирования, предоставляющий дополнительные возможности в сравнении с JUnit.
Особенности: Поддержка параметризированных тестов, группировка тестов, настройка методов конфигурации и др.
Mockito:
Описание: Библиотека для создания моков (заглушек) и проведения тестирования с использованием mock-объектов.
Особенности: Простота создания моков, поддержка верификации вызовов методов.
AssertJ:
Описание: Библиотека для улучшения читаемости и управляемости утверждений в тестах.
Особенности: Богатый и выразительный DSL для написания утверждений, поддержка различных типов данных
Hamcrest:
Описание: Библиотека для написания утверждений (matchers) в более выразительной форме.
Особенности: Читаемые утверждения с использованием матчеров, поддержка комбинирования матчеров.
Selenium:
Описание: Фреймворк для тестирования веб-приложений.
Особенности: Автоматизированное тестирование веб-интерфейсов, поддержка различных браузеров.

В чем разница между 4 и 5 junit?
JUnit 4:
Аннотации: Использует аннотации для обозначения тестов и их частей.
Параметризированные тесты: Реализуются через @RunWith(Parameterized.class).
Иерархия тестов: Основана на классах.
Расширяемость: Имеет свою архитектуру расширений.
Контекст выполнения: Основан на JUnit 4 TestRunner.
JUnit 5:
Аннотации: Вводит новый набор аннотаций для более гибкой настройки тестов.
Параметризированные тесты: Поддерживаются через @ParameterizedTest.
Иерархия тестов: Основана на интерфейсах и классах, предоставляя более гибкую структуру.
Расширяемость: Предоставляет более гибкие средства для создания пользовательских расширений.
Поддержка Kotlin: Лучше совместим с языком программирования Kotlin.
Новые возможности: Вводит новые функции, такие как условия выполнения, повторяемые тесты и динамическое создание тестов.

Как легко перейти с 4 на 5 junit?
Добавление зависимости:
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-api</artifactId>
    <version>5.8.0</version>
    <scope>test</scope>
</dependency>

Какие аннотации для работы с junit вы знаете?
Для тестовых методов:
@Test
Обозначает метод как тестовый.
Пример: @Test void myTestMethod() { ... }
@RepeatedTest
Повторяет выполнение теста заданное количество раз.
Пример: @RepeatedTest(5) void myRepeatedTest() { ... }
@ParameterizedTest
Поддерживает параметризированные тесты с различными наборами параметров.
Пример: @ParameterizedTest @CsvSource({"1, 1", "2, 2"}) void myParameterizedTest(int a, int b) { ... }
@TestFactory
Динамически создает и возвращает тесты.
Пример: @TestFactory List<DynamicTest> dynamicTests() { ... }
Для настройки тестового окружения:
@BeforeAll
Метод, выполняемый перед запуском всех тестов в классе.
Пример: @BeforeAll static void init() { ... }
@BeforeEach
Метод, выполняемый перед каждым тестовым методом.
Пример: @BeforeEach void setUp() { ... }
@AfterEach
Метод, выполняемый после каждого тестового метода.
Пример: @AfterEach void tearDown() { ... }
@AfterAll
Метод, выполняемый после завершения всех тестов в классе.
Пример: @AfterAll static void cleanUp() { ... }
Для условий выполнения тестов:
@EnabledOnOs и @DisabledOnOs`
Управление выполнением тестов в зависимости от операционной системы.
Пример: @EnabledOnOs(OS.LINUX) @Test void myLinuxTest() { ... }
@EnabledIf и @DisabledIf`
Выполнение теста на основе пользовательского условия.
Пример: @EnabledIf("myCondition()") @Test void myConditionalTest() { ... }
@EnabledIfSystemProperty и @DisabledIfSystemProperty
Управление выполнением тестов на основе системных свойств.
Пример: @EnabledIfSystemProperty(named = "my.property", matches = "true") @Test void mySystemPropertyTest() { ... }

BeforeEach и AfterEach за что отвечает?
@BeforeEach:
Назначение: Определяет метод, который будет выполняться перед каждым тестовым методом.
Использование: Используется для инициализации ресурсов и выполнения предварительных действий перед каждым тестом.
@AfterEach:
Назначение: Определяет метод, который будет выполняться после каждого тестового метода.
Использование: Используется для освобождения ресурсов и выполнения завершающих действий после каждого теста.

Можно ли временно выключить тест?
@Disabled:
Назначение: Отмечает тестовый метод или класс как отключенный, временно исключая его из выполнения.
Использование: Применяется к тестовому методу или классу, который требуется временно отключить.
@Ignore:
Назначение: Аналогично @Disabled, используется для временного отключения выполнения тестов.
Использование: Применяется к тестовому методу или классу, который требуется временно отключить.

Как можно проверить что код покрыт тестами?
Добавление зависимости в проект:
Добавить зависимость JaCoCo в файл конфигурации сборки проекта (например, pom.xml для Maven).
<build>
    <plugins>
        <plugin>
            <groupId>org.jacoco</groupId>
            <artifactId>jacoco-maven-plugin</artifactId>
            <version>0.8.7</version>
            <executions>
                <execution>
                    <id>jacoco-initialize</id>
                    <goals>
                        <goal>prepare-agent</goal>
                    </goals>
                </execution>
                <execution>
                    <id>jacoco-site</id>
                    <phase>verify</phase>
                    <goals>
                        <goal>report</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
Запуск тестов:
Выполнить тесты, используя инструмент сборки, IDE или командную строку.
Генерация отчета о покрытии:
Запустить цель verify (или другую цель, при которой генерируется отчет) для JaCoCo.
Анализ отчета:
Открыть сгенерированный отчет о покрытии в директории target/site/jacoco.

Как лучше называть тесты?
название ясно отражало, что именно тестируется. Это делает код тестов понятным и удобным для поддержки.
Если тест проваливается, его имя должно четко указывать на то,что пошло не так. Это помогает быстро определить проблему.


-----------------------------------------------------------------------------------------------------------------

